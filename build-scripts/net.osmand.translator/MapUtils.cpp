//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: MapUtils.java
//
//  Created by Remarket on 18.10.12.
//

#include <Entity.h>
#include <IOSCharArray.h>
#include <IOSClass.h>
#include <LatLon.h>
#include <MapUtils.h>
#include <Node.h>
#include <Relation.h>
#include <Way.h>
#include <java/lang/Double.h>
#include <java/lang/Long.h>
#include <java/lang/Math.h>
#include <java/lang/NullPointerException.h>
#include <java/lang/StringBuilder.h>
#include <java/util/ArrayList.h>
#include <java/util/Collection.h>
#include <java/util/Collections.h>
#include <java/util/Iterator.h>
#include <java/util/List.h>

class MapUtils {

static NSString * MapUtils_BASE_SHORT_OSM_URL_ = @"http://osm.org/go/";
static IOSCharArray * MapUtils_intToBase64_;

 static  NSString * BASE_SHORT_OSM_URL {
  return MapUtils_BASE_SHORT_OSM_URL_;
}

 static  IOSCharArray * intToBase64 {
  return MapUtils_intToBase64_;
}

 static  double getDistance ( Node* e1, Node* e2 ) {
  return  getDistance( e1.getLatitude(),  e1.getLongitude(),  e2.getLatitude(),  e2.getLongitude());
}

 static  double getDistance ( LatLon* l, double latitude, double longitude ) {
  return  getDistance( l.getLatitude(),  l.getLongitude(), latitude, longitude);
}

 static  double getDistance ( Node* e1, double latitude, double longitude ) {
  return  getDistance( e1.getLatitude(),  e1.getLongitude(), latitude, longitude);
}

 static  double getDistance ( Node* e1, LatLon* point ) {
  return  getDistance( e1.getLatitude(),  e1.getLongitude(),  point.getLatitude(),  point.getLongitude());
}

 static  double scalarMultiplication ( double xA, double yA, double xB, double yB, double xC, double yC ) {
  double multiple = (xB - xA) * (xC - xA) + (yB - yA) * (yC - yA);
  return multiple;
}

 static  double getOrthogonalDistance ( double lat, double lon, double fromLat, double fromLon, double toLat, double toLon ) {
  return  getDistance( getProjection(lat, lon, fromLat, fromLon, toLat, toLon), lat, lon);
}

 static  LatLon * getProjection ( double lat, double lon, double fromLat, double fromLon, double toLat, double toLon ) {
  double mDist = (fromLat - toLat) * (fromLat - toLat) + (fromLon - toLon) * (fromLon - toLon);
  double projection =  scalarMultiplication(fromLat, fromLon, toLat, toLon, lat, lon);
  double prlat;
  double prlon;
  if (projection < 0) {
    prlat = fromLat;
    prlon = fromLon;
  }
  else if (projection >= mDist) {
    prlat = toLat;
    prlon = toLon;
  }
  else {
    prlat = fromLat + (toLat - fromLat) * (projection / mDist);
    prlon = fromLon + (toLon - fromLon) * (projection / mDist);
  }
  return [[[LatLon alloc] initprlat, prlon] autorelease];
}

 static  double getDistance ( double lat1, double lon1, double lat2, double lon2 ) {
  double R = 6371;
  double dLat =  Math.toRadians(lat2 - lat1);
  double dLon =  Math.toRadians(lon2 - lon1);
  double a =  Math.sin(dLat / 2) *  Math.sin(dLat / 2) +  Math.cos( Math.toRadians(lat1)) *  Math.cos( Math.toRadians(lat2)) *  Math.sin(dLon / 2)*  Math.sin(dLon / 2);
  double c = 2 *  Math.atan2( Math.sqrt(a),  Math.sqrt(1 - a));
  return R * c * 1000;
}

 static  double getDistance ( LatLon* l1, LatLon* l2 ) {
  return  getDistance( l1.getLatitude(),  l1.getLongitude(),  l2.getLatitude(),  l2.getLongitude());
}

 static  LatLon * getCenter ( Entity* e ) {
  if ([e isKindOfClass:[Node class]]) {
    return  getLatLon();
  }
  else if ([e isKindOfClass:[Way class]]) {
    return  getWeightCenterForNodes( getNodes());
  }
  else if ([e isKindOfClass:[Relation class]]) {
    id<JavaUtilList> list = [[[JavaUtilArrayList alloc] init] autorelease];
    {
      id<JavaLangIterable> array__ = (id<JavaLangIterable>)  getMembers(nil);
      if (!array__) {
        @throw [[[JavaLangNullPointerException alloc] init] autorelease];
      }
      id<JavaUtilIterator> iter__ = [array__ iterator];
      while ([iter__ hasNext]) {
        Entity * fe = (Entity *) [iter__ next];
        LatLon *c = nil;
        if (!([fe isKindOfClass:[Relation class]])) {
          c =  getCenter(fe);
        }
        if (c != nil) {
          list.add(c);
        }
      }
    }
    return  getWeightCenter(list);
  }
  return nil;
}

 static  LatLon * getWeightCenter ( JavaUtilCollection* nodes ) {
  if ( nodes.isEmpty()) {
    return nil;
  }
  double longitude = 0;
  double latitude = 0;
  {
    id<JavaLangIterable> array__ = (id<JavaLangIterable>) nodes;
    if (!array__) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    id<JavaUtilIterator> iter__ = [array__ iterator];
    while ([iter__ hasNext]) {
      LatLon * n = (LatLon *) [iter__ next];
      longitude +=  n.getLongitude();
      latitude +=  n.getLatitude();
    }
  }
  return [[[LatLon alloc] initlatitude /  nodes.size(), longitude /  nodes.size()] autorelease];
}

 static  LatLon * getWeightCenterForNodes ( JavaUtilCollection* nodes ) {
  if ( nodes.isEmpty()) {
    return nil;
  }
  double longitude = 0;
  double latitude = 0;
  int count = 0;
  {
    id<JavaLangIterable> array__ = (id<JavaLangIterable>) nodes;
    if (!array__) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    id<JavaUtilIterator> iter__ = [array__ iterator];
    while ([iter__ hasNext]) {
      Node * n = (Node *) [iter__ next];
      if (n != nil) {
        count++;
        longitude +=  n.getLongitude();
        latitude +=  n.getLatitude();
      }
    }
  }
  if (count == 0) {
    return nil;
  }
  return [[[LatLon alloc] initlatitude / count, longitude / count] autorelease];
}

 static  LatLon * getMathWeightCenterForNodes ( JavaUtilCollection* nodes ) {
  if ( nodes.isEmpty()) {
    return nil;
  }
  double longitude = 0;
  double latitude = 0;
  double sumDist = 0;
  Node *prev = nil;
  {
    id<JavaLangIterable> array__ = (id<JavaLangIterable>) nodes;
    if (!array__) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    id<JavaUtilIterator> iter__ = [array__ iterator];
    while ([iter__ hasNext]) {
      Node * n = (Node *) [iter__ next];
      if (n != nil) {
        if (prev == nil) {
          prev = n;
        }
        else {
          double dist =  MapUtils.getDistance(prev, n);
          sumDist += dist;
          longitude += ( prev.getLongitude() +  n.getLongitude()) * dist / 2;
          latitude += ( n.getLatitude() +  n.getLatitude()) * dist / 2;
          prev = n;
        }
      }
    }
  }
  if (sumDist == 0) {
    if (prev == nil) {
      return nil;
    }
    return  prev.getLatLon();
  }
  return [[[LatLon alloc] initlatitude / sumDist, longitude / sumDist] autorelease];
}

 static  double checkLongitude ( double longitude ) {
  while (longitude < -180 || longitude > 180) {
    if (longitude < 0) {
      longitude += 360;
    }
    else {
      longitude -= 360;
    }
  }
  return longitude;
}

 static  double checkLatitude ( double latitude ) {
  while (latitude < -90 || latitude > 90) {
    if (latitude < 0) {
      latitude += 180;
    }
    else {
      latitude -= 180;
    }
  }
  if (latitude < -85.0511) {
    return -85.0511;
  }
  else if (latitude > 85.0511) {
    return 85.0511;
  }
  return latitude;
}

 static  int get31TileNumberX ( double longitude ) {
  longitude =  checkLongitude(longitude);
  long long l = 1l << 31;
  return (int) ((longitude + 180.0) / 360.0 * l);
}

 static  int get31TileNumberY ( double latitude ) {
  latitude =  checkLatitude(latitude);
  double eval =  Math.log( Math.tan( Math.toRadians(latitude)) + 1 /  Math.cos( Math.toRadians(latitude)));
  long long l = 1l << 31;
  if (eval > JavaLangMath_PI) {
    eval = JavaLangMath_PI;
  }
  return (int) ((1 - eval / JavaLangMath_PI) / 2 * l);
}

 static  double get31LongitudeX ( int tileX ) {
  return  MapUtils.getLongitudeFromTile(21, tileX / 1024.0f);
}

 static  double get31LatitudeY ( int tileY ) {
  return  MapUtils.getLatitudeFromTile(21, tileY / 1024.0f);
}

 static  double getTileNumberX ( float zoom, double longitude ) {
  if (longitude == 180.0) {
    return  getPowZoom(zoom) - 1;
  }
  longitude =  checkLongitude(longitude);
  return (longitude + 180.0) / 360.0 *  getPowZoom(zoom);
}

 static  double getTileNumberY ( float zoom, double latitude ) {
  latitude =  checkLatitude(latitude);
  double eval =  Math.log( Math.tan( Math.toRadians(latitude)) + 1 /  Math.cos( Math.toRadians(latitude)));
  if ( Double.isInfinite(eval) ||  Double.isNaN(eval)) {
    latitude = latitude < 0 ? -89.9 : 89.9;
    eval =  Math.log( Math.tan( Math.toRadians(latitude)) + 1 /  Math.cos( Math.toRadians(latitude)));
  }
  double result = (1 - eval / JavaLangMath_PI) / 2 *  getPowZoom(zoom);
  return result;
}

 static  double getTileEllipsoidNumberY ( float zoom, double latitude ) {
  double E2 = (double) latitude * JavaLangMath_PI / 180;
  long long sradiusa = 6378137;
  long long sradiusb = 6356752;
  double J2 = (double)  Math.sqrt(sradiusa * sradiusa - sradiusb * sradiusb) / sradiusa;
  double M2 = (double)  Math.log((1 +  Math.sin(E2)) / (1 -  Math.sin(E2))) / 2 - J2 *  Math.log((1 + J2 *  Math.sin(E2)) / (1 - J2 *  Math.sin(E2))) / 2;
  double B2 =  getPowZoom(zoom);
  return B2 / 2 - M2 * B2 / 2 / JavaLangMath_PI;
}

 static  double getLatitudeFromEllipsoidTileY ( float zoom, float tileNumberY ) {
  double MerkElipsK = 0.0000001;
  long long sradiusa = 6378137;
  long long sradiusb = 6356752;
  double FExct = (double)  Math.sqrt(sradiusa * sradiusa - sradiusb * sradiusb) / sradiusa;
  double TilesAtZoom =  getPowZoom(zoom);
  double result = (tileNumberY - TilesAtZoom / 2) / -(TilesAtZoom / (2 * JavaLangMath_PI));
  result = (2 *  Math.atan( Math.exp(result)) - JavaLangMath_PI / 2) * 180 / JavaLangMath_PI;
  double Zu = result / (180 / JavaLangMath_PI);
  double yy = (tileNumberY - TilesAtZoom / 2);
  double Zum1 = Zu;
  Zu =  Math.asin(1 - ((1 +  Math.sin(Zum1)) *  Math.pow(1 - FExct *  Math.sin(Zum1), FExct)) / ( Math.exp((2 * yy) / -(TilesAtZoom / (2 * JavaLangMath_PI))) *  Math.pow(1 + FExct *  Math.sin(Zum1), FExct)));
  while ( Math.abs(Zum1 - Zu) >= MerkElipsK) {
    Zum1 = Zu;
    Zu =  Math.asin(1 - ((1 +  Math.sin(Zum1)) *  Math.pow(1 - FExct *  Math.sin(Zum1), FExct)) / ( Math.exp((2 * yy) / -(TilesAtZoom / (2 * JavaLangMath_PI))) *  Math.pow(1 + FExct *  Math.sin(Zum1), FExct)));
  }
  return Zu * 180 / JavaLangMath_PI;
}

 static  double getLongitudeFromTile ( float zoom, double x ) {
  return x /  getPowZoom(zoom) * 360.0 - 180.0;
}

 static  double getPowZoom ( float zoom ) {
  if (zoom >= 0 && zoom -  Math.floor(zoom) < 0.05f) {
    return 1 << ((int) zoom);
  }
  else {
    return  Math.pow(2, zoom);
  }
}

 static  float calcDiffPixelX ( float rotateSin, float rotateCos, float dTileX, float dTileY, float tileSize ) {
  return (rotateCos * dTileX - rotateSin * dTileY) * tileSize;
}

 static  float calcDiffPixelY ( float rotateSin, float rotateCos, float dTileX, float dTileY, float tileSize ) {
  return (rotateSin * dTileX + rotateCos * dTileY) * tileSize;
}

 static  double getLatitudeFromTile ( float zoom, double y ) {
  int sign = y < 0 ? -1 : 1;
  double result =  Math.atan(sign *  Math.sinh(JavaLangMath_PI * (1 - 2 * y /  getPowZoom(zoom)))) * 180.0 / JavaLangMath_PI;
  return result;
}

 static  int getPixelShiftX ( int zoom, double long1, double long2, int tileSize ) {
  return (int) (( getTileNumberX(zoom, long1) -  getTileNumberX(zoom, long2)) * tileSize);
}

 static  int getPixelShiftY ( int zoom, double lat1, double lat2, int tileSize ) {
  return (int) (( getTileNumberY(zoom, lat1) -  getTileNumberY(zoom, lat2)) * tileSize);
}

 static  void addIdsToList ( JavaUtilCollection* source, JavaUtilList* ids ) {
  {
    id<JavaLangIterable> array__ = (id<JavaLangIterable>) source;
    if (!array__) {
      @throw [[[JavaLangNullPointerException alloc] init] autorelease];
    }
    id<JavaUtilIterator> iter__ = [array__ iterator];
    while ([iter__ hasNext]) {
      Entity * e = (Entity *) [iter__ next];
      ids.add( Long.valueOf( e.getId()));
    }
  }
}

 static  void sortListOfEntities ( JavaUtilList* list, double lat, double lon ) {
  Collections.sort(list, [[[MapUtils_$1 alloc] initlat, lon] autorelease]);
}

 static  NSString * buildShortOsmUrl ( double latitude, double longitude, int zoom ) {
  long long lat = (long long) (((latitude + 90.0) / 180.0) * (1l << 32));
  long long lon = (long long) (((longitude + 180.0) / 360.0) * (1l << 32));
  long long code =  interleaveBits(lon, lat);
  JavaLangStringBuilder *str = [[[JavaLangStringBuilder alloc] init10] autorelease];
  str.append(MapUtils_BASE_SHORT_OSM_URL_);
  for (int i = 0; i <  Math.ceil((zoom + 8) / 3.0); i++) {
    str.append([((IOSCharArray *) NIL_CHK(MapUtils_intToBase64_)) charAtIndex:(int) ((code >> (58 - 6 * i)) & (int) 0x3f)]);
  }
  for (int j = 0; j < (zoom + 8) % 3; j++) {
    str.append('-');
  }
  str.append(@"?m");
  return  str.description();
}

 static  long long interleaveBits ( long long x, long long y ) {
  long long c = 0;
  for (wchar_t b = 31; b >= 0; b--) {
    c = (c << 1) | ((x >> b) & 1);
    c = (c << 1) | ((y >> b) & 1);
  }
  return c;
}

 static  float unifyRotationDiff ( float rotate, float targetRotate ) {
  float d = targetRotate - rotate;
  while (d >= 180) {
    d -= 360;
  }
  while (d < -180) {
    d += 360;
  }
  return d;
}

 static  float unifyRotationTo360 ( float rotate ) {
  while (rotate < 0) {
    rotate += 360;
  }
  while (rotate > 360) {
    rotate -= 360;
  }
  return rotate;
}

 static  double alignAngleDifference ( double diff ) {
  while (diff > JavaLangMath_PI) {
    diff -= 2 * JavaLangMath_PI;
  }
  while (diff <= -JavaLangMath_PI) {
    diff += 2 * JavaLangMath_PI;
  }
  return diff;
}

 static  double degreesDiff ( double a1, double a2 ) {
  double diff = a1 - a2;
  while (diff > 180) {
    diff -= 360;
  }
  while (diff <= -180) {
    diff += 360;
  }
  return diff;
}

+ (void)initialize {
  if (self == [MapUtils class]) {
    MapUtils_intToBase64_ = [ IOSCharArray.arrayWithCharacters((wchar_t[]){ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '_', '@' }, count64) retain];
  }
}

}


class MapUtils_$1 {

- (double)val$lat {
  return val$lat_;
}

- (void)setVal$lat:(double)newVal$lat {
  val$lat_ = newVal$lat;
}

- (double)val$lon {
  return val$lon_;
}

- (void)setVal$lon:(double)newVal$lon {
  val$lon_ = newVal$lon;
}


  int compare ( id* o1, id* o2 ) {
  return  Double.compare( MapUtils.getDistance( o1.getLatLon(), val$lat_, val$lon_),  MapUtils.getDistance( o2.getLatLon(), val$lat_, val$lon_));
}

 (bool)isEqual:(id)param0 {
  return (bool) [super isEqualparam0];
}

- (id)init ( double outer$0, double outer$1 ) {
  if ((self = [super init])) {
    val$lat_ = outer$0;
    val$lon_ = outer$1;
  }
  return self;
}

}


